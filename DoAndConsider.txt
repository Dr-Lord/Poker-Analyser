---- Poker Analyser Do and Consider File
--
--      Author:
--          Dr-Lord
--
--      Version:
--          0.1 - 20-21/03/2015
--
--      Description:
--          Poker analysing shell.
--          This package contains all the things I currently have to do or
--          am considering doing. It also contains various notes and testing
--          data for the program.
--
--   Sections:
--       1 - To Do
--       2 - To Consider
--       3 - Notes
--       4 - Testing Data
--


---- 1 - TO DO -----------------------------------------------------------------

    REAL PLAN:
        FIX THIS IN NEW VERSION:
let Just cs = sequence $ map toCard ["1d", "9d", "8d", "7d"]
checkAllHandTypes [] cs


JUST SOLVED:
            [(FullHouse,[FourOfAKind]),(Straight,[FourOfAKind])]
            [(Straight,[FullHouse])]
            [(StraightFlush,[Flush])]
            [(FourOfAKind,[StraightFlush])]

    COMPARE OLD AND NEW possFullHouse!!!!!!!!!!!!!!!!!!!!!!!!

                (NEW PROBLEMS ARISE BECAUSE THE COMPLETERS LONGER THAN THE CARDS LEFT
                TO DRAW ARE NOW TESTED AS WELL)


        REVISIT THE noSupersets APPROACH TO BETTER PROBABILITIES, DOING IT DURING A FOLD,
        IN ORDER TO REDUCE THE NUMBER OF ELEMENTS CHECKED EVERY TIME
            NOTE THAT INTEGRATING THIS WILL ALSO ALLOW THE REMOVAL OF MANY CHECKS AND FILTERS
            IN MANY poss FUNCTIONS THEMSELVES
                PERHAPS MAKE A SEPARATE VERSION OF SUPER-OPTIMISED (NO CHECKS ON cs FOR BETTER HTS)
                poss FUNCTIONS TO BE USED ONLY WITH countBetter...
                    OOORRRRR
                    PERHAPS MOVE THOSE TESTS IN SEPARATE FUNCTIONS AND CALL THEM ONLY WHEN USING
                    countAllHandTypes, AND NOT WITH countBetterHandTypes
                        PERHAPS ADD STANDARD CHECKS FOR ALL BETTER HTS IN THE UNION OF compelters
                        WITH cs AFTER EACH poss FUNCTION (CASUS: ["1d", "9d", "8d", "7d"] ++
                        EITHER [[Six of Spades,Six of Clubs,Six of Diamonds,Six of Hearts],
                        [Jack of Spades,Jack of Clubs,Jack of Diamonds,Jack of Hearts] YIELDS
                        A StraightFlush INSTEAD OF A FourOfAKind])

            PERHAPS MAKE A NEW (==) FOR CARD LISTS, CHECKING THAT THE LENGTH IS THE SAME AND
            THAT EACH ELEMENT OF ONE IS IN THE OTHER

        LITTLE BY LITTLE, EMBED THE ABSTRACT PART IN EACH CONCRETE COUNTER
            REMOVE FROM THE ABSTRACT COUNT ALL THE BETTER HandTypes INSTANCES
        OOOOOOOOOOORRRRR
            PLAN TO INCLUDE THE APPROPRIATE ABSTRACT ONES IN THE COMMON PART
            OF ALL CONCRETE ONES

        PARALLELISE STUFF, ESPECIALLY IN EACH poss FUNCTION
            NOTE: COMMENTED OUT AT PRESENT; AWAITING TEST FOR WORTHINESS OF OVERHEAD

        AT SOME STAGE DO THE REAL TEST/CHECK: NOT A quickCheck, BUT ON ALL POSSIBLE HANDS


    POSSIBLE PATHS:
        - FIGURE OUT A WAY TO GET NICE PROBABILITIES FROM THE DATA ALREADY PRODUCED
                IS THERE A SMART WAY TO MERGE ALL POSSIBLE ONES FROM BETTER HTS
                WITHIN THE CARDS LEFT TO DRAW AND REMOVING THEIR NUMBER FROM THE
                COUNTER IN QUESTION?
        - PROCEED WITH THE ABSTRACT HAND COUNTERS


    POSSIBLE PLAN:
        PROCEED WITH THE ABSTRACT HAND COUNTERS;
            AT THE END THEY WILL PROVIDE THE PROBABILITY, AND IF ASKED THE PRACTICAL ONES
            CAN PROVIDE THE ACTUAL HANDS. ALSO, NOT ALL HANDS ARE NEEDED TO RANK BEST POSSIBLE,
            WORST POSSIBLE AND PRESENT HAND
                PROBABLY RENOUNCE ANY-CARD-NUMBER CALCULATIONS; UP TO 7 IS FINE, XD

        ? - BUILD SUPER QUICK SUIT-OR-VALUE-OR-CARD-PATTERN-BASED CHECKING FUNCTION
            FOR EACH HANDTYPE;
            WHENEVER A BETTER PATTERN IS MATCHED IN AN ABSTRACT COUNT FUNCTION, DECREASE
            ITS COUNT BY ONE; PERHAPS USE INCLUSION EXCLUSION PRINCIPLE TO OVERLAP PATTERNS;




    MODIFY ALL count FUNCTIONS TO RETURN THE POSSIBLE RELEVANT CARDS, AND MAKE THEM BE CALLED
    BY A COMMON PART ONE IN ORDER TO OPTIMISE PERFORMANCE (AS OPPOSED TO ALL OF THEM CALLING
    IT). THEN BUILD A SINGLE ONE CALLING FUNCTION FRO PRACTICALITY (OR MAKE ONE WHICH ACCEPTS LISTS OF HTS)



    USE ALTSIGNSSUM TO IMPLEMENT AN INCLEXLPRINC IN THE ABSTRHANDCOUNTERS WHEN
    THERE IS NO INSTANCE ALREADY PRESENT AND HANDS HAVE TO BE DISCARDED FROM THE
    POSSIBLE ONES, WHICH HAVE DUPLICATES
        OR
    THINK ABOUT THE COMPLETERS WHICH ARE SUBSETS OF OTHER COMPLETERS (USUALLY
    WHEN POSSIBLE BETTER VERSIONS OF AN ALREADY PRESENT INSTANCE EXIST (LIKE Flushes));
    THEY CAN DRIVE THE totHtProb OVER 2, BUT IT MIGHT BE OK, SINCE THE NEXT STEP IS
    TO GET RANKS FROM THE COMPLETERS
        SHOULD THEY BE REMOVED? OR SHOULD THE SUPERSET ONES BE? OR NOT AT ALL?

    CONSIDER THIS:
        BUILD A GRAPH (NOT A TREE BECAUSE IT WILL HAVE CYCLES) (OR A TREE WITH
        DUPLICATES: A PROBABILITY TREE) FROM THE aphs OF EACH count FUNCTION'S OUTPUT
                UNFEASEABLE BECAUSE THEN ALL THE CARDS WHICH ARE NOT SUPPOSED TO BE
                ADDED HAVE TO BE REMOVED FROM THE KICKERS TO EVERY POSSIBLE HAND

            OR

        EITHER concat IN DECREASING HT ORDER ALL THE COMPLETERS AND REMOVE SUBSETS,
            THEN PUTTING THEM BACK IN THE APPROPRIATE HT
        OR TAKE THEM OUT DURING GENERATION, REMOVING THE NEED OF ALL THAT TESTING


    THIS SEEMS TO BE THE CHOICE: REMOVE ALL SUPERSETS OF POSSIBLE COMPLETERS
        (THIS TO GET THE TOTAL PROBABILITY OF THE HT REGARDLESS OF RANKS)
        OR APPLY A VERSION OF THE INCLUSION EXCUSION PRINCIPLE

    PARALLELISE STUFF
        DETERMINE WHICH MODULE IS THE MOST PERTINENT IN EACH CASE:
            Control.Parallel (JUST par AND pseq)
            Control.Parallel.Strategies (CONTAINS THE Deepseq STUFF, INCLUDING
                INSTANCE DERIVATION (WHICH IS NOT THE SAME AS DERIVABLE))

    MAKE FUNCTIONS (OR IMPLEMENT IN THE ABSTRACTED PART OF THE count ONES) RANKING
    THE BEST AND WORST INSTANCES IN A count

    ADD SHORT CIRCUIT VALUES FOR SAY, alreadyDrawn >= tcn, BEING 1 IF IT IS AN INSTANCE
    OF THE CURRENT HT OR 0 OTHERWISE



    MAKE USE OR CHANGE OR DELETE THE Prob DATA TYPE

    DO SOMETHING WITH THE Deck TYPE; USE IT IN THE count FUNCTIONS
    IF IT IS NOT USED, REMOVE IT ALTOGETHER BUT LEAVE THE # OF CARDS IN IT
        OR MENTION THAT IT MAKES MUCH MORE SENSE IF CARDS ARE NOT PUT BACK INTO IT

    IMPLEMENT ALL CHECKS FOR NON ALLOWED ACTIONS AND CARDS IN THE SHELL, ESPECIALLY
    HAVING THE SAME CARD TWICE, WHICH BREAKS MOST count FUNCTIONS



    count FUNCTIONS:

        RETEST THE EMPTY LISTS CASES: HighCard AND TwoPair SEEM NOT TO RETURN ANYTHING
        IN FACT, LOOK CLOSELY AT EACH OF:
map simpleTotProbs $ countAllHandTypes [7] initialDeck [] []
[[(RoyalFlush,3.2320622e-5),(StraightFlush,2.908856e-4),(FourOfAKind,1.6806724e-3),(FullHouse,3.0252103e-2),(Flush,4.1273434e-2),(Straight,8.2417585e-2),(ThreeOfAKind,8.235294e-2),(TwoPair,0.0),(OnePair,1.2352942),(HighCard,0.0)]]

        IN FACT, REDO THE PROBABILITY CALCULATION
            RELOOK AT THE ABSTRACT COUNTERS ON WIKIPEDIA

        NOTE THAT NOT ALL count FUNCTIONS CAN GENERATE SUBSETS AMONG THEIR COMPLETERS;
        APPLY noSupersets ONLY TO THEM

        RETOUCH countHandTypes FUNCTION BY PERFORMING THE GENERAL is TESTS (OR EQUIVALENT Bool ONES)
        TO DETERMINE WHICH count FUNCTIONS WOULD JUST RETURN [], THEREBY SAVING PRECIOUS TIME

        FINAL FINAL CHECK: MAKE SURE count FUNCTIONS COUNT EXACTLY THE PREDICTED AMOUNT
        OF INSTANCES FOR THE EMPTY LISTS CASE

        MAKE A SEPARATE PROPERTY QUICKCHECK FOR countBetterHandTypes, WHICH RETURNS ONLY
        THE REALISTIC COUNTS, WHICH WILL MAKE THE TESTS MORE APPROPRIATE AND FASTER





    BE AWARE, WHEN LATER DECIDING ON HOW TO USE THE PROBABILITIES (SINGLE
    BY SINGLE OR ALSO INCLUDING THE TOTAL NUMBER OF INSTANCES), THAT BY
    REMOVING THE INSTANCES WHICH ARE ALSO BETTER INSTANCES, SOME INSTANCES
    HAVE BEEN REMOVED, THEREFORE THE COLLECTIVE PROBABILITY BASED ONLY ON
    THE NUMBER OF INSTANCES HAS BEEN AFFECTED

    DECIDE WHAT LEVEL OF ABSTRACTION SHOULD BE EXTRACTED FROM THE ALREADY MADE
    count FUNCTIONS: JUST THE WHOLE possHands PART? THE WHOLE STRUCTURE?

    TAKE INTO ACCOUNT THE DIFFERENCE BETWEEN SINGLE INSTANCES OF A HandType AND
    DISTINCT INSTANCES (THE LATTER BEING ISOMORPHOUS W.R.T. SUITS BIJECTIONS)
        (SEE WIKIPEDIA ARTICLE ON POKER PROBABILITIES)

    RECONCILE Quality AND ranks

    MAKE A FUNCTION RETURNING ALL THE HANDTYPES' PROBABILITIES FOR THE PLAYER
    AND OTHER PLAYERS SIDE BY SIDE

    FINAL TEST AT THE VERY END: COMPARE WITH RESULTS FROM: http://poker-helper.co.uk/
    GOOD SKETCH OF PROBABILITIES: https://en.wikipedia.org/wiki/Poker_probability_(Texas_hold_%27em)

    LOOK AT HAND DOMINATION

    MAKE A DEFAULT maybe FALLBACK FUNCTION FOR EACH COMMAND (LOOK AT toCard) (OR NOT)

    ATTEMPT TO BRUTE FORCE SARTING CARDS RANKS

    IN GENERAL: NEED TO IMPLEMENT CONDITIONAL PROBABILITIES (A|B) IN ORDER TO
    CATER FOR THE FACT THAT SOME CARDS THAT ARE NEEDED FOR A HAND COULD HAVE
    ALREADY BEEN EXTRACTED AND BE IN OTHER PLAYERS' HANDS. (OR NOT)



---- 2 - TO CONSIDER -----------------------------------------------------------

    REDO THE WHOLE HandCounters PURELY MATHEMATICALLY, AND PERHAPS LATER ADD THE
    GENERATION OF ALL THE POSSIBLE HANDS
        OR PERHAPS EXTRACT USEFUL ABSTRACTIONS AND PARTS FROM THESE NEW ONES AND
        IMPLEMENT THEM IN THE OLD ONES

    STORING AND UPDATING ALL THE COUNTS AND PROBABILITIES FOR THE USER AND THE
    OTHER PLAYERS IN EACH Frame

    REDOING ALL is FUNCTIONS IMITATING THE SHORTER AND MORE EFFICIENT VERSIONS
    CREATED AD HOC FOR MOST count FUNCTIONS
        ALSO MAKING THOSE TESTS MORE UNIFORM THROUGHOUT THE count FUNCTIONS
                OR
    REALLY CONSIDER JUST BULDING A DUMMED DOWN VERSION OF HandType CHEKERS (Bool OUTPUT)
    TO UNIFY THE WAY THEY ARE CHECKED, SACRIFICING SOME SPEED
        OR, JUST GENERALISE THE noSOMEHANDTYPE FUNCTIONS AND CALL THEM WHERE NEEDED

    REVISING THE GENERAL NOMENCLATURE TO MAKE IT VERY POKER-LEXICON-LIKE
    (E.G. THE PLAYER'S CARDS ARE CALLED POCKET CARDS, ETC.)

    FLIPPING THE FIRST TWO ARGUMENTS OF count FUNCTION (SEPARATE THE TWO [Card]
    WITH THE Deck, JUST FOR MORE CLARITY)

    PERHAPS REDO rank FUNCTIONS TO REALLY MATCH THE HANDS WITH THEIR REAL PLACE

    THINK ABOUT count FUNCTIONS, DO THEY REALLY NEED TO RETURN THE Card LISTS?
    CAN THEY NOT JUST RETURN THE NUMBER OF LISTS AND THE RANKS OF EACH?
    THEN IT DOES NOT MATTER WHAST CARDS THEY ACTUALLY CONTAIN; THEY ARE JUST
    SOME X CARDS TO BE DRAWN

    REMOVING RoundEnd Action AND SIMPLY USE THE Won ONE, PERHAPS MAKING IT A
    WonRound WITH ANOTHER WonGame ONE

    THINK ABOUT THE DIFFERENCE BETWEEN PROBABILITIES/LIKELYHOODS CALCULATED FROM
    THE SINGLE CARDS VS THOSE CALCULATED FROM HOW MANY WAYS EXIST OF ACHIEVING A
    SPECIFIC HandType (WHICH IS THE FIRST VALUE OF THE count FUNCTIONS)

    THE FACT THAT THE FIRST VALUE IN THE TUPLE RETURNED BY countANYHANDTYPE ARE
    JUST THE LENGTH OF THE SECOND VALUE... PERHAPS REMOVE IT (OR NOT, PERHAPS
    BECAUSE OF LAZYNESS IF ONLY THE FIRST ONE IS REQUIRED)?

    BRUSH UP Quick Check AND STUFF IN ORDER TO TEST ALL FUNCTIONS UP TO NOW,
    ESPECIALLY THE RANKING ONES

    SHOULD THE HandTypes IN whatIs AND bestHandType BE RETURNED
    DIRECTLY BY EACH HANDTYPE CHECKER INSTEAD OF BEING ADDED IN THESE FUNCTIONS?

    THE FACT THAT THE CARDS THAT ARE OUT ARE NOT IN, XD
    MODIFY POSSIBILITIES ACCORDING TO WHAT CARDS ARE KNOWN TO BE OUT

    INTERESTING IDEA TO START WITH:
        RANK ALL 52! HANDS 10 TIMES, ONE PER HandType. THEN CREATE A SINGLE LIST
        MERGING THEM SOMEHOW...

    FUNCTION whatProb WHICH IS GIVEN THE PRESENT CARDS AND STUFF LIKE
    Either Value Suit OR [Card] AND RETURNS THE PROBABILITY OF GETTING SUCH A
    SET FROM THE PRESENT ONES
        PERHAPS THE need FIELD IN Prob SHOULD BE OF THE TYPE OF THAT STUFF
        OR Prob SHOULD ALSO HAVE A cards FIELD LIKE Hand.

    COULD JUST BRUTE FORCE ALL POSSIBLE HANDS, SORT THEM, RANK THEM AND SAVE THE
    RESULT AS A DATA STRUCTURE TO IMPORT.
        OR DO IT SLIGHTLY MORE SMARTLY, BY GROUPING THEM.

        START BY DOING IT FOR STARTING PAIRS. VERY IMPORTANT. DO IT!!!!!!!!

    REALLY THINK ABOUT INCREMENTAL VS COMPREHENSIVE PROBABILITY DETERMINATION

    EVEN IF THE INCREMENTAL PROBABILITY ENDS UP NOT BEING IMPLEMENTED, MAKE IT
    SO THAT EVERYTHING IS FIRST CALCULATED FOR THE TABLE SO THAT PROBABILITIES
    FOR ALL PLAYERS ARE KNOWN, AND THEN APPLY IT TO THE SPECIFIC PLAYER'S HAND

    ADD AN "OR" CLAUSE IN THE need FIELD OF Prob

    CONSIDER REMOVING THE HandType VALUE FROM Hand AND Prob, AND JUST MAKE
    Data.MapS (DICTIONARIES) OF ( (HandType,Prob) AND (HandType,Hand) ) OR
    (HandType,Either Prob Hand)

    PERHAPS GROUP straightProb AND highCardProb TOGETHER

    INTRODUCE better (OR SOMETHING SIMILAR) FIELD IN Prob, REPRESENTING THE
    SMALLEST CARD REQUIRED TO GET A BETTER HAND THAN THE PRESENT.
    IT IS DIFFERENT FROM THE need FIELD, AND IT SHOULD WORK WITH IT

    INTRODUCE quality FIELD IN Prob, REPRESENTING HOW GOOD A HandType IT IS
    AMONG ALL POSSIBLE SAME HandTypes
        PERHAPS IT SHOULD BE IN Hand INSTEAD?
            AND A SAME TYPE FIELD SUCH AS "BEST POSSIBLE" COULD BE IN Prob
        REGARDLESS:
            NEED A SET OF BIJECTIONS (ONE PER HandType)
            F: HandType x |-> [0..numberOfAllPossibleShuchHandTypes-1]
                OR PERHAPS FROM 1 TO (NOT -1)
                E.G. : HighCard -> [0..13-1]

    STRUCTURING CAN BE THE FOLLOWING:
     ONE FUNCTION TAKES THE TABLE AND RETURNS Prob OF ALL HandtypeS;
     THEN THE PLAYER'S HAND IS TAKEN IN AND MAPPED OVER THE PROBABILITIES;
     EITHER STOP AT THE FIRST 100% OR DO THEM ALL (OR BE LAZY AFTER THE FIRST ONE)

    MAKE ALL THESE FUNCTIONS ASSUME THE PREVIOUS ONE HAS RUN?
    MAKE THEM WORK BY COUNTING THE CARDS THAT ARE NOT "OUT"?
    AND PERHAPS ALL POSSIBLE OTHER PLAYERS' HANDS?


    DISTINCTIVE PROPERTY OF THIS PROJECT WILL BE THE QUALITY OF HANDS:
    FROM THE SET OF ALL POSSIBLE 5 CARDS (52C5), THE 10 PARTITIONS IN DIFFERENT
    HANDTYPES WILL BE IDENTIFIED AND INDIVIDUALLY SORTED BY CREATING BIJECTIONS
    (IN FACT SIMILAR TO A fromEnum) FROM EACH OF THEM TO INTEGERS FROM 0 TO THE
    NUMBER OF ALL POSSIBLE SUCH HANDS IN ORDER.



---- 3 - NOTES -----------------------------------------------------------------

    THERE WILL BE MANY HANDS WHICH WILL BE IN MORE THAN ONE HANDTYPE

    THE ONLY HANDS WHICH WILL NEED TO BE CALCULATED EACH TIME ARE
    THE ONES THAT WOULD BEAT THE PLAYER'S OWN.

    THERE CAN BE A CRUDER VERSION OF QUALITY OF HANDS: BY NOT SORTING ALL
    SINGLE POSSIBLE ONES BUT BY GROUPING THEM BY KINDS.
    E.G. SORT FULLHOUSES BY WHAT THE TRIS IS OF AND WHAT THE PAIR IS OF.



---- 4 - TESTING DATA ----------------------------------------------------------

let h = probsToHand (sort a) (reverse $ sort b)
let prs = [Prob HighCard 1 [], Prob FullHouse 0.3 [Left Ace], Prob Straight 0.8 [Right Diamonds]]



let Just a = sequence $ map toCard ["ks", "qh"]
let Just b = sequence $ map toCard ["3h"]
countHighCard initialDeck b a



let Just a = sequence $ map toCard ["ks", "qh", "jd", "1c", "kh", "ks", "qd"]
let Just b = sequence $ map toCard ["3h", "5c", "ks", "1s", "2d", "ah", "9d"]

let pls = [Player 1 50 10 (Fold 1) [] (Hand HighCard (HV Two) 0 []), Player 2 300 30 (Bet 2 30) [] (Hand HighCard (HV Two) 0 []), Player 3 200 50 (Raise 3 50) [] (Hand HighCard (HV Two) 0 [])]
let fr = Frame (Discard 3) 4 2 1 initialDeck a 0 pls
let fl = [("action", FA (Fold 2)), ("dealer", FI 3)]
let ss = addFrame [fr] fl


gameShell ss

spn 5
sun 1
spb 500
s1d
ci ks qh
p2b 5
p3b 10
p4f
p5f
p1b 10
p2b 5
cf kh qs kd
p2c jc jd
p3c kc 5d

fff
re

